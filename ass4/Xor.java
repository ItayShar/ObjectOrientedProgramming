import java.util.Map;

/**
 * The Xor class contains attributes and different methods used on xor expressions.
 */
public class Xor extends BinaryExpression implements Expression {
    /**
     * The Xor method constructs a new Xor instance.
     * @param left - the left expression in the instance.
     * @param right - the right expression in the instance.
     */
    public Xor(Expression left, Expression right) {
        super(left, right);
    }

    /**
     * The evaluate method calculates the truth value of an instance based on a map instance.
     * @param assignment - a map instance with keys and values of the variables in the BaseExpression instance.
     * @return - the truth value of an instance based on the map instance.
     * @throws Exception
     */
    public Boolean evaluate(Map<String, Boolean> assignment) throws Exception {
        return (this.left.evaluate(assignment) ^ this.right.evaluate(assignment));
    }

    /**
     * The evaluate Method calculates the truth value of an instance.
     * @return - The truth value of an instance.
     * @throws Exception
     */
    public Boolean evaluate() throws Exception {
        return (this.left.evaluate() ^ this.right.evaluate());
    }

    /**
     * The toString method converts the Or instance into a string form.
     * @return - a string form of the instance.
     */
    public String toString() {
        return ("(" +  this.left.toString() + " ^ " + this.right.toString() + ")");
    }

    /**
     * The assign method replaces a variable with an Expression.
     * @param var - the variable that will be replaced.
     * @param expression - the expression that will replace the variable.
     * @return - a new expression generated by the replacement.
     */
    public Expression assign(String var, Expression expression) {
        return new Xor(left.assign(var, expression), right.assign(var, expression));
    }

    /**
     * The nandify method converts an expression to a nand-only expression equal to the original expression.
     * @return - a nand-only expression equal to the original expression.
     */
    public Expression nandify() {
        return new Nand(new Nand(this.left.nandify(), new Nand(this.left.nandify(), this.right.nandify())),
                new Nand(this.right.nandify(), new Nand(this.left.nandify(), this.right.nandify())));
    }

    /**
     * The norify method converts an expression to a nor-only expression equal to the original expression.
     * @return - a nor-only expression equal to the original expression.
     */
    public Expression norify() {
        return new Nor(new Nor(new Nor(this.left.norify(), this.left.norify()), new Nor(this.right.norify(),
                this.right.norify())), new Nor(this.left.norify(), this.right.norify()));
    }

    /**
     * The simplify method generates a simplified version of an expression instance.
     * @return - a simplified expression instance
     */
    public Expression simplify() {
            if (this.left.toString() == "T" && this.right.toString() != "T") {
                return new Not(this.right).simplify();
            }
            if (this.right.toString() == "T" && this.left.toString() != "T") {
                return new Not(this.left).simplify();
            }
            if (this.left.toString() == "F" && this.right.toString() != "F") {
                return this.right.simplify();
            }
            if (this.right.toString() == "F" && this.left.toString() != "F") {
                return this.left.simplify();
            }
            if (this.left.toString() == this.right.toString()) {
                return new Val(false);
            }
            return new Xor(this.left.simplify(), this.right.simplify()).simplify();
    }
}
